
import pandas as pd #leitura

from sklearn.model_selection import train_test_split #modelo de aprendizado para teste

from sklearn.preprocessing import LabelEncoder #labelencoder para substituir título por números

from keras.utils import np_utils #np_utils.to_categorical(classe) para melhorar a visualizacao --> em vez de ver os elementos como 0,1,2 --> 001,010,100;

from keras.models import Sequential #neurônios sequenciais

from keras.layers import Dense #camadas densas -> estão ligadas a toda a rede posterior



dados = pd.read_csv('iris.csv') #leitura

atributos = dados.iloc[:,0:4].values #[linha,coluna] -> [todas linhas, coluna 0 a 3]

classe = dados.iloc[:,4].values #[todas as linhas, coluna 4]



lab = LabelEncoder()

classe = lab.fit_transform(classe) #transformando as palavras em números 

classe = np_utils.to_categorical(classe) #transformando visualizacao de array -> 0 para 001



atributos_treino, atributos_teste, classe_treino, classe_teste = train_test_split(atributos,classe,test_size=0.25) #separacao de dados do treino para teste



rede = Sequential() #implementacao de rede tipo sequencial

rede.add(Dense(units = 4, activation = 'relu', input_dim = 4 )) # activation = sensitiveoutput   input_dim = quant. de atributos

rede.add(Dense(units=8, activation = 'relu')) #relu = tipo de activation

rede.add(Dense(units = 3, activation = 'softmax')) #softmax indicado para mais de dois tipos de saídas

#units -> neurônios



rede.compile(optimizer = 'adam', loss = 'categorical_crossentropy', metrics = ['categorical_accuracy']) #compile methods



rede.fit(atributos_treino,classe_treino, batch_size=50, epochs=100, validation_split=0.1) #enfiar todo o modo de treinamento na rede real



resultados = rede.evaluate(atributos_teste,classe_teste) #var resultados recebe o teste

